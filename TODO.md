## Stack Allocation and Strings
> This has been solved as of 11/14/2020
> Note: string workspace has been removed. See allocators::string_store.h
One problem that I find interesting is trying to do efficient string manipulation. What I might do is make it so that string.h:create_string copies a string from a given pointer into a stack based allocator, or something similar. Not necessarily a buffer, but more like a stack allocation mechanism that persists as long as main persists. That'll ensure that the allocation is never deallocated automatically unless main returns. I am thinking that string_store.h could do stack based allocations by creating at least 4KB on the stack primarily for string manipulation. This would make string copy, string concatenation, and other forms of string manipulation (formatting, trimming, etc) much more efficient, and easier to work with, instead of passing around pointers to a string constant in the data section of the executable.

## Deque (Double Ended Queue)
> In progress
> Note: I am getting varying results with the deque_create procedure. Sometimes when I run it with cman run allocators (inside commons) or just cman run (inside allocators), I get on average ~35 ms (although that may not be exactly representative of the actual benchmark, it may be a bit less than that), but sometimes it takes over a second and at one point took over 6 seconds.

This data structure is necessary to implement my channel implementation. The double-ended queue is
a queue that has a pointer to the start and end. It also gives the ability to push to the start (head) or to the end (tail). This will give me a fifo effect so that I can make the channel truly be a fifo data structure between multiple fibers. The problem then is that if I make it like a regular
queue, then I will need to do a rearranging/sorting algorithm which could add time complexity. The time complexity is shaved off a few microseconds per push/pop due to the lack of allocations/deallocations per operation. Instead, I might have to go with a middle-out queue mechanism so that if we allocate 1024 bytes, the first place it'll allocate to is `(1024 / 2) - (size / 2)`, because we want to offset the middle of the data structure. Now this is a problem because this will cause offsetting of varying sizes that may overlap with boundaries. What I want to do instead is just push to the end and pop at the beginning. If we just increment the pop pointer at the head, and push at the end, then what happens is the more work there becomes in a smaller amount of time, then the more you're gonna stagger away from the start of the queue as you're pushing and popping in short amounts of time. Eventually, you'll stagger to the end and basically get a memory/array index out of bounds or a buffer overrun. That's what I want to avoid.

Right now this only creates the deque but does not add or remove anything currently. It's designed as a circular buffer and uses results to notify the caller of anything wrong that may have happened.